{"name":"Boilerplate","tagline":"Quick Restify Sequelize boilerplate","body":"# λαlbao Boilerplate\r\nFor quickly creating apps built on [restify](http://restify.com/) and\r\n[sequelize](http://sequelize.readthedocs.org/en/latest/). Originally\r\ncreated for spinning up new services in a production environment, it\r\nfeatures some opinionated structure to simplify developing in a\r\nmulti-configuration environment. It assumes that you want your service\r\nto be testable, inspectable, easily configurable, and able to work\r\nwith other services without you helping. Like all boilerplates, it is\r\nbased on enlightened laziness. \r\n\r\n# Features\r\n\r\n### Multiple configuration\r\nProbably the most unique feature is the way configuration is\r\nhandled. It's easy to set a default configuration which is extended\r\nincrementally according to different settings in `NODE_ENV`. And there\r\nis a command-line interface for inspecting your configuration at any\r\ntime. See below for more details.\r\n\r\n### Cluster support\r\nIt is assumed that your service will use the cluster module. So this\r\nprovides scaffolding that will run a process for each available CPU,\r\nas well as log cluster activity out of the box. It is also separated\r\nfrom the app code to allow for easy testing. \r\n\r\n### Friendly `require` functionality\r\nRequire entire directories, and the files they contain will be\r\navailable as attributes of the required object. For example, if you\r\nsave a file in the `handlers` directory called `get-funky.js`, you can\r\ndo this elsewhere:\r\n\r\n```\r\nvar handlers = require(__dirname + '/handlers');\r\napp.get('/funky', handlers.getFunky);\r\n```\r\n\r\nNotice that even though the filename was `hyphen-cased`, the object it\r\nexports is added to the parent directory in `camelCase`. The trick is\r\nin the `handlers/index.js` file. Such a file exists in some, but not\r\nall, folders. If you would like this functionality in any folder,\r\nsimply copy the `index.js` file into that folder.\r\n\r\n### Quick Setup\r\nIf you have a database server running, you can have a database and\r\nbegin modeling it and setting up fixtures within one minute. Once your\r\nmodels are created, the same setup will create a new database with\r\nschema in the same amount of time. Deploying or getting a new\r\ndeveloper up and running is a snap.\r\n    \r\n# Dependencies\r\nThis will install a minimal number of nuts and bolts for your app:\r\n\r\n- [restify](https://www.npmjs.com/package/restify): A nice, light\r\n  framework for creating RESTful services with both a server and\r\n  client component.\r\n- [bunyan](https://www.npmjs.com/package/bunyan): A logging framework\r\n  with some great production features and DTrace support.\r\n- [sequelize](https://www.npmjs.com/package/sequelize): A promise-based ORM that can work with PostgreSQL, MySQL,\r\n  MariaDB, SQLite, and MSSQL. \r\n\r\nAnd a number of tools that we've found useful for testing. Unlike the\r\nabove dependencies, you may find this boilerplate useful whether or\r\nnot you use all of these:\r\n\r\n- mocha: A testing framework with multiple reporting styles.\r\n- chai: Friendly assertions.\r\n- sinon: Crucial mocking, stubbing, spying library for unit tests.\r\n- supertest: Write tests as HTTP requests.\r\n- nock: A mocking library to stub remote servers for testing your\r\n  service's client operations.\r\n\r\n\r\n# Get Started\r\nBefore we start, this opinionated boilerplate assumes that you will\r\nhave `NODE_ENV` set to `development` in your local shell\r\nenvironment. If you don't know how to do that, look it up. It's easy,\r\nbut I won't waste the space here for it.\r\n\r\nFirst, install the boilerplate generator as a global npm module.\r\n```\r\n$ git clone https://github.com/lukealbao/boilerplate.git\r\n$ npm install -g boilerplate/\r\n```\r\n\r\nThe boilerplate generator will be installed as a global binary\r\navailable on your `PATH` as `bp`. To build a new project, simply\r\ncreate a new directory where you want it built, move to that\r\ndirectory, and run `bp`:\r\n\r\n```\r\n$ mkdir new-project\r\n$ cd new-project\r\n$ bp\r\n```\r\n\r\nYou will be asked to name your project. You should use the convention\r\nof a short, lowercase name with hyphens separating different words.\r\n\r\n```\r\nEnter a name for your project:\r\n```\r\n\r\nYour new app will have an initial commit, and you can get started.\r\n\r\n\r\n# Configure \r\nConfiguration is a chore. This will be a little easier. This\r\nboilerplate attempts to modularize configuration to facilitate\r\nconfiguring different environments. Here's what you need to know:\r\n\r\n1. An \"environment\" is defined by the `NODE_ENV` string in the\r\n   environment of the user running the Node process. This appears in\r\n   `process.env.NODE_ENV` variable in a Node process. Setting this is\r\n   done via your shell environment.\r\n2. The `config` folder exports a single object, which contains the\r\n   *active* configuration according to the current\r\n   `NODE_ENV`. Elsewhere in your application code, you should\r\n   `require('./config')` and let the environment set the differences.\r\n3. You set your default configurations in `config/defaults.js`.\r\n4. You set overrides or extensions for various environments by\r\n   configuring `config/<environment-name>.js`.\r\n5. Environment configurations *extend* and *overwrite* defaults. Thus,\r\n   any configuration in the `default.js` that is not overwritten by an\r\n   environment configuration will be present in the exported\r\n   configuration - which helps minimize duplication. \r\n\r\nSee `config/index.js` for more details on customizing\r\nconfigurations.\r\n\r\n**PROTIP:** From the root of the project directory,\r\nyou can call `make printcfg` to see the entire `config` exported in\r\nthe current environment, or use `make cfg-<element>` for a specific\r\nitem. If the `<element>` is a non-primitive object, you can access\r\nits attributes via dot notation. If you are looking to check a\r\nconfiguration in an array, you can still use dot notation. Everything\r\nthat is available when a module requires `config` is inspectable:\r\n\r\n```\r\n$ make cfg-server\r\n{ name: 'BoilerplateApp', host: '0.0.0.0', port: 4434 }\r\n\r\n$ make cfg-server.name\r\nBoilerplateApp\r\n```\r\n\r\n## Set up a database\r\n\r\n```\r\n$ make newdb\r\n```\r\n\r\nProvided you have a database server running, this will create a new\r\ndatabase. When getting started, you will likely want to change a few\r\nconfigurations before you run `make newdb`. You'll want a different\r\ndatabase name, and if you have something other than MySQL running on\r\nyour localhost, you'll need to specify that, too. You can do that via the\r\n`config/development.js` (or `config.default.js`!) files. \r\n\r\nThis command is non-destructive and will only create a database if it\r\ndoes not exist.\r\n\r\n# Conventions\r\n\r\n## App code\r\n- Put your restify declarations in `api.js`. By default, `index.js`\r\n  will spin up a worker running `api.js` for each available CPU.\r\n- Define handlers in the `handlers/` directory. Each file in that\r\n  directory should export a single restify-compliant (i.e.,\r\n  `(req, res, next)` signature) function. The `handlers/index.js`\r\n  helper script will export the `handlers` directory as a single\r\n  object, attaching all files as camelCased sub-object. So if you add\r\n  a new handler in `/handlers/get-all-the-things.js`, you can access\r\n  it with `require('./handlers').getAllTheThings`. Pretty cool!\r\n\r\n\r\n```\r\n├── Makefile\r\n├── README.md\r\n├── api.js\r\n├── config\r\n│   ├── defaults.js\r\n│   ├── development.js\r\n│   └── unittest.js\r\n├── docs\r\n│   ├── index.restdown\r\n│   ├── branding\r\n│   └── public\r\n├── handlers\r\n├── lib\r\n│   ├── db.js\r\n│   ├── errors.js\r\n│   └── models\r\n├── log\r\n├── test\r\n│   └── fixtures\r\n│       ├── db.js\r\n│       └── restify.js\r\n└── tools\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}