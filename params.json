{"name":"Boilerplate","tagline":"Quick Restify Sequelize boilerplate","body":"\r\n# λαlbao Boilerplate\r\nThis repo provides a barebones structure for a Nodejs service built on\r\n`node-restify` and `sequelize`. It allows easy configuring of separate\r\nenvironments via extending defaults in the `config/` directory, as\r\nwell as some specialized `make` targets for easy setup and deployment.\r\n\r\n# Get started\r\n- Download the source @ https://github.com/lukealbao/boilerplate/releases/latest\r\n- Run `git init`\r\n- That's it. If you want deeper instructions (which you do), keep reading.\r\n\r\n# Initial configuration\r\nBefore you start writing some code, you'll need to do a couple house\r\ncleaning things first.\r\n\r\n## Personalize your repo\r\n- [ ] Set up a git pre-commit hook for linting:\r\n  `make githooks`\r\n- [ ] Run `npm install`. Out of the box you will get the dependencies\r\n  listed below.\r\n- [ ] Change the `name` and `version` in `package.json`.\r\n\r\n## Configure \r\nConfiguration is a chore. This will be a little easier. This\r\nboilerplate attempts to modularize configuration to facilitate\r\nconfiguring different environments. Here's what you need to know:\r\n\r\n1. An \"environment\" is defined by the `NODE_ENV` string in the\r\n   environment of the user running the Node process. This appears in\r\n   `process.env.NODE_ENV` variable in a Node process. Setting this is\r\n   done via your shell environment.\r\n2. The `config` folder exports a single object, which contains the\r\n   *active* configuration according to the current\r\n   `NODE_ENV`. Elsewhere in your application code, you should\r\n   `require('./config')` and let the environment set the differences.\r\n3. You set your default configurations in `config/defaults.js`.\r\n4. You set overrides or extensions for various environments by\r\n   configuring `config/<environment-name>.js`.\r\n5. Environment configurations *extend* and *overwrite* defaults. Thus,\r\n   any configuration in the `default.js` that is not overwritten by an\r\n   environment configuration will be present in the exported\r\n   configuration - which helps minimize duplication. \r\n\r\nSee `config/index.js` for more details on customizing\r\nconfigurations. **PROTIP:** From the root of the project directory,\r\nyou can call `make printcfg` to see the entire `config` exported in\r\nthe current environment, or use `make cfg-<element>` for a specific\r\nitem using dot notation. E.g., `make cfg-db.user` will print `root`\r\nunder a fresh boilerplate install.\r\n\r\n## Set up a database\r\n`make newdb` will give you a new database, provided your database\r\ndaemon is running, and you have configured a database name in your `config`.\r\n\r\nOnce you have defined your models and added them to the object\r\nexported by `lib/db.js`, you can `make checkdb`, and it will create\r\nyour schema.\r\n\r\n# Conventions\r\n\r\n## App code\r\n- Put your restify declarations in `api.js`. By default, `index.js`\r\n  will spin up a worker running `api.js` for each available CPU.\r\n- Define handlers in the `handlers/` directory. Each file in that\r\n  directory should export a single restify-compliant (i.e.,\r\n  `(req, res, next)` signature) function. The `handlers/index.js`\r\n  helper script will export the `handlers` directory as a single\r\n  object, attaching all files as camelCased sub-object. So if you add\r\n  a new handler in `/handlers/get-all-the-things.js`, you can access\r\n  it with `require('./handlers').getAllTheThings`. Pretty cool!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}